<!DOCTYPE html>
<html>
    <head>
        <title>Unclear Throne</title>
        <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
        <script src="http://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
    </head>
    <body>
        <canvas width="800" height="600" id="gameCanvas" style="cursor: none;"></canvas>
        <script>

/** THE GAME ITSELF **********************************************************/
var TSZ = 40; // Tile size
var MSZ = 50; // Map size
var NOTICE_RANGE = 550;
var PURSUE_RANGE = 700;
var FOLLOW_RANGE = 190;

var weaponTypes = {
    slowSixShooter: {
        img: {x:0, y:80, w:14, h:7},
        shot: {x:16, y:81, w:9, h:5},
        reload: 2400,
        numShots: 1,
        dmg: 2,
        range: 300,
        speed: 0.6,
        jitter: 0.05
    },
    sixShooter: {
        img: {x:0, y:80, w:14, h:7},
        shot: {x:16, y:81, w:9, h:5},
        reload: 700,
        numShots: 1,
        dmg: 2,
        range: 450,
        speed: 1.0,
        jitter: 0.05
    },
    rifle: {
        img: {x:0, y:90, w:32, h:10},
        shot: {x:16, y:81, w:9, h:5},
        reload: 1500,
        numShots: 1,
        dmg: 3,
        range: 700,
        speed: 1.6,
        jitter: 0.01
    },
    shotgun: {
        img: {x:0, y:102, w:27, h:10},
        shot: {x:16, y:81, w:9, h:5},
        reload: 1800,
        numShots: 5,
        dmg: 1,
        range: 200,
        speed: 0.8,
        jitter: 0.2
    },
    gatlingGun: {
        img: {x:41, y:81, w:37, h:11},
        shot: {x:16, y:81, w:9, h:5},
        reload: 200,
        numShots: 1,
        dmg: 2,
        range: 500,
        speed: 1.2,
        jitter: 0.1
    },
    abyssalProjector: {
        img: {x:41, y:94, w:30, h:11},
        shot: {x:74, y:96, w:5, h:5},
        reload: 50,
        numShots: 1,
        dmg: 1,
        range: 500,
        speed: 0.6,
        jitter: 0
    }
};

var enemyTypes = {
    blackHat: {
        img: {x: 3*TSZ, y: 1*TSZ, w: TSZ, h: TSZ},
        speed: 0.2,
        hp: 3,
        weapon: weaponTypes.slowSixShooter
    },
    tumbleweed: {
        img: {x: 4*TSZ, y: 1*TSZ, w: TSZ, h: TSZ},
        speed: 0.3,
        hp: 1,
        weapon: weaponTypes.shotgun
    },
    angryPony: {
        img: {x: 5*TSZ, y: 1*TSZ, w: TSZ, h: TSZ},
        speed: 0.4,
        hp: 5,
        weapon: weaponTypes.sixShooter
    },
    train: {
        img: {x: 6*TSZ, y: 1*TSZ, w: TSZ, h: TSZ},
        speed: 0.1,
        hp: 9,
        weapon: weaponTypes.gatlingGun
    }
};

var tileTypes = {
    dirt: {
        img: {x: 0, y: 0, w: TSZ, h: TSZ},
        wall: false
    },
    dirtWall: {
        img: {x: 1*TSZ, y: 0, w: TSZ, h: TSZ},
        wall: true
    }
};

var playerTypes = {
    taquitoJames: {
        img: {x: 0, y: 1*TSZ, w: TSZ, h: TSZ},
        hp: 6,
        speed: 0.3
    },
    elGato: {
        img: {x: TSZ, y: 1*TSZ, w: TSZ, h: TSZ},
        hp: 9,
        speed: 0.3
    },
    spur: {
        img: {x: 2*TSZ, y: 1*TSZ, w: TSZ, h: TSZ},
        hp: 6,
        speed: 0.45
    }
};

var player = {
    type: playerTypes.taquitoJames,
    weapon: weaponTypes.sixShooter,
    reload: 0,
    x: MSZ * TSZ / 2,
    y: MSZ * TSZ / 2,
    hp: 6
};

var map = [];
var enemies = [];

function splort(x, y, r) {
    for (var xx = x - r; xx < x + r; xx++) { for (var yy = y - r; yy < y + r; yy++) {
        if (xx < 0 || xx >= MSZ || yy < 0 || yy >= MSZ) { continue; }
        if ((xx - x) * (xx - x) + (yy - y) * (yy - y) <= r * r) {
            map[yy][xx] = tileTypes.dirt;
        }
    }}
}

function canSplort(x, y, r) {
    var connected = 0;
    for (var xx = x - r; xx < x + r; xx++) { for (var yy = y - r; yy < y + r; yy++) {
        if (xx < 1 || xx >= MSZ - 1 || yy < 1 || yy >= MSZ - 1) { return false; }
        if ((xx - x) * (xx - x) + (yy - y) * (yy - y) <= r * r && !map[yy][xx].wall) {
            connected++;
        }
    }}
    return connected > 0 && connected < r * r / 4;
}

function splortRect(x, y, w, h) {
    for (var xx = x; xx < x + w; xx++) { for (var yy = y; yy < y + h; yy++) {
        map[yy][xx] = tileTypes.dirt;
    }}
}

function canSplortRect(x, y, w, h) {
    var connected = 0;
    for (var xx = x; xx < x + w; xx++) { for (var yy = y; yy < y + h; yy++) {
        if (xx < 1 || xx >= MSZ - 1 || yy < 1 || yy >= MSZ - 1) { return false; }
        if (!map[yy][xx].wall) {
            connected++;
        }
    }}
    return connected > 0 && connected < 9;
}

function wallProportion() {
    var wall = 0;
    for (var y = 0; y < MSZ; y++) { for (var x = 0; x < MSZ; x++) {
        if (map[y][x].wall) { wall++; }
    }}
    return wall * 1.0 / MSZ / MSZ;
}

function generateMap() {
    map = new Array(MSZ);
    for (var i = 0; i < MSZ; i++) {
        map[i] = new Array(MSZ);
    }
    for (var y = 0; y < MSZ; y++) { for (var x = 0; x < MSZ; x++) {
        map[y][x] = tileTypes.dirtWall;
    }}
    splort(MSZ / 2, MSZ / 2, 1);
    while (wallProportion() > 0.7) {
        var x = Math.floor(Math.random() * MSZ);
        var y = Math.floor(Math.random() * MSZ);
        var w = 5 + Math.ceil(Math.random() * 7);
        var h = 2;
        if (canSplortRect(x, y, w, h)) { splortRect(x, y, w, h); }
        x = Math.floor(Math.random() * MSZ);
        y = Math.floor(Math.random() * MSZ);
        w = 2;
        h = 5 + Math.ceil(Math.random() * 7);
        if (canSplortRect(x, y, w, h)) { splortRect(x, y, w, h); }
        x = Math.floor(Math.random() * MSZ);
        y = Math.floor(Math.random() * MSZ);
        var r = Math.ceil(Math.random() * 7);
        if (canSplort(x, y, r)) { splort(x, y, r); }
    }
    for (var i = 0; i < 30; i++) {
        var x = Math.random() * MSZ * TSZ;
        var y = Math.random() * MSZ * TSZ;
        if (wallAt(x, y) || wallAt(x + TSZ, y) || wallAt(x, y + TSZ) || wallAt(x + TSZ, y + TSZ)) {
            continue;
        }
        if ((x - MSZ * TSZ / 2) * (x - MSZ * TSZ / 2) + (y - MSZ * TSZ / 2) * (y - MSZ * TSZ / 2) < 200 * 200) {
            continue;
        }
        var type = [enemyTypes.blackHat, enemyTypes.tumbleweed, enemyTypes.angryPony, enemyTypes.train][Math.floor(Math.random() * 4)];
        enemies.push({
            type: type,
            x: x,
            y: y,
            reload: 0,
            hp: type.hp,
            noticed: false,
            moveWait: 0
        });
    }
}

generateMap();

var shots = [];

function shoot(weapon, x, y, angle, byPlayer) {
    shots.push({
        weapon: weapon,
        srcX: x,
        srcY: y,
        x: x,
        y: y,
        dx: Math.cos(angle) * weapon.speed,
        dy: Math.sin(angle) * weapon.speed,
        angle: angle,
        byPlayer: byPlayer
    });
}

function wallAt(x, y) {
    x = Math.floor(x / TSZ);
    y = Math.floor(y / TSZ);
    return x < 0 || x >= MSZ || y < 0 || y >= MSZ || map[y][x].wall;
}

function obstacleAt(x, y, self) {
    if (self != player) {
        if (x >= player.x && y >= player.y && x < player.x + TSZ && y < player.y + TSZ) {
            return player;
        }
    }
    for (var i = 0; i < enemies.length; i++) {
        var enemy = enemies[i];
        if (enemy == self) { continue; }
        if (x >= enemy.x && y >= enemy.y && x < enemy.x + TSZ && y < enemy.y + TSZ) {
            return enemy;
        }
    }
    return null;
}

function unitObstacleAt(x, y, self) {
    return obstacleAt(x, y, self) || obstacleAt(x + TSZ, y, self) || obstacleAt(x, y + TSZ, self) || obstacleAt(x + TSZ, y + TSZ, self);
}

function input(ms) {
    if (down("W") && !wallAt(player.x + 5, player.y - player.type.speed * ms) && !wallAt(player.x + TSZ - 5, player.y - player.type.speed * ms) && unitObstacleAt(player.x, player.y - player.type.speed * ms, player) == null) {
        player.y -= player.type.speed * ms;
    }
    if (down("S") && !wallAt(player.x + 5, player.y + TSZ + player.type.speed * ms) && !wallAt(player.x + TSZ - 5, player.y + TSZ + player.type.speed * ms) && unitObstacleAt(player.x, player.y + player.type.speed * ms, player) == null) { 
        player.y += player.type.speed * ms;
    }
    if (down("A") && !wallAt(player.x - player.type.speed * ms, player.y + 5) && !wallAt(player.x - player.type.speed * ms, player.y + TSZ - 5) && unitObstacleAt(player.x - player.type.speed * ms, player.y, player) == null) { 
        player.x -= player.type.speed * ms;
    }
    if (down("D") && !wallAt(player.x + TSZ + player.type.speed * ms, player.y + 5) && !wallAt(player.x + TSZ + player.type.speed * ms, player.y + TSZ - 5) && unitObstacleAt(player.x + player.type.speed * ms, player.y, player) == null) { 
        player.x += player.type.speed * ms;
    }
    if (mouseDown && player.reload == 0) {
        player.reload = player.weapon.reload;
        var angle = Math.atan2(cursor.y - canvas.height / 2, cursor.x - canvas.width / 2);
        shoot(
            player.weapon,
            player.x + TSZ / 2 + Math.cos(angle) * player.weapon.img.w / 2,
            player.y + TSZ / 2,
            angle,
            true);
    }
    click = null;
}

function update(ms) {
    player.reload = Math.max(player.reload - ms, 0);
    for (var i = 0; i < shots.length; i++) {
        var remove = false;
        var shot = shots[i];
        shot.x += shot.dx * ms;
        shot.y += shot.dy * ms;
        if ((shot.x - shot.srcX) * (shot.x - shot.srcX) + (shot.y - shot.srcY) * (shot.y - shot.srcY) > shot.weapon.range * shot.weapon.range) {
            remove = true;
        }
        if (wallAt(shot.x, shot.y)) {
            remove = true;
        }
        var hitUnit = obstacleAt(shot.x, shot.y, null);
        if (hitUnit == player && !shot.byPlayer) {
            hitUnit.hp -= shot.weapon.dmg;
            remove = true;
        }
        if (hitUnit && hitUnit != player && shot.byPlayer) {
            hitUnit.hp -= shot.weapon.dmg;
            remove = true;
        }
        if (remove) {
            shots.splice(i, 1);
            i--;
        }
    }
    for (var i = 0; i < enemies.length; i++) {
        var enemy = enemies[i];    
        enemy.reload = Math.max(0, enemy.reload - ms);
        enemy.moveWait = Math.max(0, enemy.moveWait - ms);
        var distSq = (enemy.x - player.x) * (enemy.x - player.x) + (enemy.y - player.y) * (enemy.y - player.y);
        if (distSq < NOTICE_RANGE * NOTICE_RANGE) {
            enemy.noticed = true;
        }
        if (distSq > PURSUE_RANGE * PURSUE_RANGE) {
            enemy.noticed = false;
        }
        if (enemy.noticed) {
            var towardsPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            if (distSq > FOLLOW_RANGE * FOLLOW_RANGE && enemy.moveWait == 0) {
                // Move towards the player.
                var newX = enemy.x + Math.cos(towardsPlayer) * enemy.type.speed * ms;
                var newY = enemy.y + Math.sin(towardsPlayer) * enemy.type.speed * ms;
                if (!wallAt(newX, newY) && !wallAt(newX + TSZ, newY) && !wallAt(newX, newY + TSZ) && !wallAt(newX + TSZ, newY + TSZ) && unitObstacleAt(newX, newY, enemy) == null) {
                    enemy.x = newX;
                    enemy.y = newY;
                } else {
                    enemy.moveWait = 500;
                }
            }
            if (distSq < enemy.type.weapon.range * enemy.type.weapon.range && enemy.reload == 0) {
                enemy.reload = enemy.type.  weapon.reload;
                // Shoot at the player
                shoot(
                    enemy.type.weapon,
                    enemy.x + TSZ / 2,
                    enemy.y + TSZ / 2,
                    towardsPlayer,
                    false
                );
            }
        }
        if (enemy.hp <= 0) {
            enemies.splice(i, 1);
            i--;
        }
    }
}

var graphicsImage = new Image();
graphicsImage.src = "gfx.png";

function img(img, x, y) {
    c.drawImage(graphicsImage, img.x, img.y, img.w, img.h, x, y, img.w, img.h);
}

function draw() {
    c.fillStyle = "#333333";
    c.fillRect(0, 0, canvas.width, canvas.height);
    c.translate(canvas.width / 2 - player.x - TSZ / 2, canvas.height / 2 - player.y - TSZ / 2);
    for (var y = 0; y < MSZ; y++) { for (var x = 0; x < MSZ; x++) {
        img(map[y][x].img, x * TSZ, y * TSZ);
    }}
    for (var i = 0; i < enemies.length; i++) {
        var enemy = enemies[i];
        img(enemy.type.img, enemy.x, enemy.y);    
    }
    img(player.type.img, player.x, player.y);
    for (var i = 0; i < shots.length; i++) {
        var shot = shots[i];
        c.translate(shot.x, shot.y);
        c.rotate(shot.angle);
        img(shot.weapon.shot, -shot.weapon.shot.w / 2, -shot.weapon.shot.h / 2);
        c.resetTransform();
        c.translate(canvas.width / 2 - player.x - TSZ / 2, canvas.height / 2 - player.y - TSZ / 2);
    }
    var weaponAngle = Math.atan2(cursor.y - canvas.height / 2, cursor.x - canvas.width / 2);
    c.translate(player.x + TSZ / 2, player.y + TSZ / 2);
    c.rotate(weaponAngle);
    img(player.weapon.img, 0, 0);
    c.resetTransform(); 
    c.fillStyle = "white";
    c.fillRect(cursor.x - 10, cursor.y - 1, 20, 2);
    c.fillRect(cursor.x - 1, cursor.y - 10, 2, 20);
    for (var i = 0; i < player.hp; i++) {
        img({x:TSZ*2, y:TSZ*2, w:TSZ, h:TSZ}, 10 + 50 * i, 10);
    }
}


/** THE GAME "ENGINE" ********************************************************/
var canvas = document.getElementById("gameCanvas");
var c = canvas.getContext("2d");
var keys = {};
var click = null;
var mouseDown = false;
var cursor = {x: 300, y: 300};

// Listen for key presses.
function canvasKeyDown(e) {
    keys[String.fromCharCode(e.which)] = true;
}

function canvasKeyUp(e) {
    keys[String.fromCharCode(e.which)] = false;
}

function down(key) {
    return !!keys[key];
}

$('body').keydown(canvasKeyDown);
$('body').keyup(canvasKeyUp);

// Listen for mouse stuff.
function canvasClick(e) {
    click = { "x": e.offsetX, "y": e.offsetY };
}

function canvasMouseDown(e) {
    mouseDown = true;
}

function canvasMouseUp(e) {
    mouseDown = false;
}

function canvasMove(e) {
    cursor = { "x": e.offsetX, "y": e.offsetY };
}

$('#gameCanvas').click(canvasClick).mousemove(canvasMove).mousedown(canvasMouseDown).mouseup(canvasMouseUp);

// Set up game loop.
var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
var lastUpdate = new Date().getTime();

function nextFrame() {
    var currentTime = new Date().getTime();
    input(currentTime - lastUpdate);
    click = null;
    update(currentTime - lastUpdate);
    draw();
    lastUpdate = currentTime;
    requestAnimationFrame(nextFrame);
}

// Once everything is set up, start game loop.
requestAnimationFrame(nextFrame);
        </script>
    </body>
</html>
